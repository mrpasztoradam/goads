package goads

import (
	"encoding/binary"
	"fmt"
	"sync"
	"time"

	"github.com/mrpasztoradam/goads/ams"
)

// NotificationMode defines how notifications are triggered
type NotificationMode uint32

const (
	// NotificationCyclic triggers notifications cyclically
	NotificationCyclic NotificationMode = 3
	// NotificationOnChange triggers notifications when value changes
	NotificationOnChange NotificationMode = 4
)

// NotificationTransMode defines when notifications are transmitted
type NotificationTransMode uint32

const (
	// TransModeServerCycle transmits notifications on server cycle
	TransModeServerCycle NotificationTransMode = 3
	// TransModeServerOnChange transmits notifications immediately on change
	TransModeServerOnChange NotificationTransMode = 4
	// TransModeCyclic transmits notifications cyclically
	TransModeCyclic NotificationTransMode = 10
)

// NotificationAttribs defines attributes for a notification request
type NotificationAttribs struct {
	Length        uint32                // Length of data in bytes
	TransMode     NotificationTransMode // Transmission mode
	MaxDelay      uint32                // Maximum delay in 100ns units
	CycleTime     uint32                // Cycle time in 100ns units
	Reserved      [16]byte              // Reserved for future use
}

// NotificationSample contains a notification data sample
type NotificationSample struct {
	Handle    uint32    // Notification handle
	Timestamp time.Time // Timestamp of notification
	Data      []byte    // Notification data
}

// NotificationCallback is called when a notification is received
type NotificationCallback func(sample NotificationSample)

// notificationHandler manages notifications for a specific handle
type notificationHandler struct {
	handle     uint32
	varName    string
	callback   NotificationCallback
	symbolInfo *Symbol
}

// NotificationManager manages ADS device notifications
type NotificationManager struct {
	client      *Client
	targetAddr  ams.Address
	senderAddr  ams.Address
	handlers    map[uint32]*notificationHandler
	mu          sync.RWMutex
	stopCh      chan struct{}
	running     bool
}

// NewNotificationManager creates a new notification manager
func NewNotificationManager(client *Client, targetAddr, senderAddr ams.Address) *NotificationManager {
	return &NotificationManager{
		client:     client,
		targetAddr: targetAddr,
		senderAddr: senderAddr,
		handlers:   make(map[uint32]*notificationHandler),
		stopCh:     make(chan struct{}),
	}
}

// Subscribe creates a notification subscription for a variable
func (nm *NotificationManager) Subscribe(
	varName string,
	cycleTime time.Duration,
	callback NotificationCallback,
) (uint32, error) {
	// Get symbol handle
	handle, err := nm.client.GetSymHandleByName(varName, nm.targetAddr, nm.senderAddr)
	if err != nil {
		return 0, fmt.Errorf("failed to get handle for %s: %w", varName, err)
	}

	// Get symbol info for data length
	symbol, err := GetSymbol(nm.client, varName, nm.targetAddr, nm.senderAddr)
	if err != nil {
		nm.client.ReleaseHandle(handle, nm.targetAddr, nm.senderAddr)
		return 0, fmt.Errorf("failed to get symbol info: %w", err)
	}

	// Create notification attributes
	attribs := NotificationAttribs{
		Length:    symbol.Size,
		TransMode: TransModeServerOnChange,
		MaxDelay:  uint32(cycleTime.Nanoseconds() / 100), // Convert to 100ns units
		CycleTime: uint32(cycleTime.Nanoseconds() / 100),
	}

	// Build request data: handle (4) + attribs (32)
	reqData := make([]byte, 36)
	binary.LittleEndian.PutUint32(reqData[0:4], handle)
	binary.LittleEndian.PutUint32(reqData[4:8], attribs.Length)
	binary.LittleEndian.PutUint32(reqData[8:12], uint32(attribs.TransMode))
	binary.LittleEndian.PutUint32(reqData[12:16], attribs.MaxDelay)
	binary.LittleEndian.PutUint32(reqData[16:20], attribs.CycleTime)

	// Send add device notification request (IndexGroup: 0xF005, IndexOffset: handle)
	resp, err := nm.client.ReadWrite(
		0xF005,        // Index group for notification by handle
		handle,        // Index offset is the variable handle
		36,            // Request data length
		reqData,       // Request data
		nm.targetAddr,
		nm.senderAddr,
	)
	if err != nil {
		nm.client.ReleaseHandle(handle, nm.targetAddr, nm.senderAddr)
		return 0, fmt.Errorf("failed to add notification: %w", err)
	}

	if resp.ErrorCode != 0 {
		nm.client.ReleaseHandle(handle, nm.targetAddr, nm.senderAddr)
		return 0, fmt.Errorf("add notification error: %d", resp.ErrorCode)
	}

	// Extract notification handle from response (first 4 bytes)
	if len(resp.Data) < 4 {
		nm.client.ReleaseHandle(handle, nm.targetAddr, nm.senderAddr)
		return 0, fmt.Errorf("invalid notification response")
	}
	notificationHandle := binary.LittleEndian.Uint32(resp.Data[0:4])

	// Store handler
	nm.mu.Lock()
	nm.handlers[notificationHandle] = &notificationHandler{
		handle:     handle,
		varName:    varName,
		callback:   callback,
		symbolInfo: symbol,
	}
	nm.mu.Unlock()

	return notificationHandle, nil
}

// Unsubscribe removes a notification subscription
func (nm *NotificationManager) Unsubscribe(notificationHandle uint32) error {
	nm.mu.Lock()
	handler, exists := nm.handlers[notificationHandle]
	if !exists {
		nm.mu.Unlock()
		return fmt.Errorf("notification handle %d not found", notificationHandle)
	}
	delete(nm.handlers, notificationHandle)
	nm.mu.Unlock()

	// Build request data: notification handle (4 bytes)
	reqData := make([]byte, 4)
	binary.LittleEndian.PutUint32(reqData, notificationHandle)

	// Send delete device notification request
	resp, err := nm.client.Write(
		0xF006,        // Index group for delete notification
		0,             // Index offset is 0
		reqData,       // Notification handle
		nm.targetAddr,
		nm.senderAddr,
	)
	if err != nil {
		return fmt.Errorf("failed to delete notification: %w", err)
	}

	if resp.ErrorCode != 0 {
		return fmt.Errorf("delete notification error: %d", resp.ErrorCode)
	}

	// Release the variable handle
	return nm.client.ReleaseHandle(handler.handle, nm.targetAddr, nm.senderAddr)
}

// Start begins processing notifications
func (nm *NotificationManager) Start() error {
	nm.mu.Lock()
	if nm.running {
		nm.mu.Unlock()
		return fmt.Errorf("notification manager already running")
	}
	nm.running = true
	nm.stopCh = make(chan struct{})
	nm.mu.Unlock()

	// Start goroutine to process notifications
	go nm.processNotifications()

	return nil
}

// Stop stops processing notifications
func (nm *NotificationManager) Stop() {
	nm.mu.Lock()
	if !nm.running {
		nm.mu.Unlock()
		return
	}
	nm.running = false
	close(nm.stopCh)
	nm.mu.Unlock()
}

// processNotifications processes incoming notification packets
func (nm *NotificationManager) processNotifications() {
	// This is a placeholder - in a real implementation, you would:
	// 1. Listen for ADS device notification packets (command ID 8)
	// 2. Parse the notification stamps from the packet
	// 3. Look up the handler for each notification handle
	// 4. Call the callback with the notification data
	//
	// For now, this would require integration with the client's receive loop
	// to dispatch notification packets separately from request/response packets
	
	<-nm.stopCh
}

// UnsubscribeAll removes all notification subscriptions
func (nm *NotificationManager) UnsubscribeAll() error {
	nm.mu.Lock()
	handles := make([]uint32, 0, len(nm.handlers))
	for h := range nm.handlers {
		handles = append(handles, h)
	}
	nm.mu.Unlock()

	var lastErr error
	for _, h := range handles {
		if err := nm.Unsubscribe(h); err != nil {
			lastErr = err
		}
	}

	return lastErr
}
